#enables color in the terminal bash shell export
export CLICOLOR=1
#sets up the color scheme for list export
export LSCOLORS=gxfxcxdxbxegedabagacad
#sets up the prompt color (currently a green similar to linux terminal)
export PS1='\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;36m\]\w\[\033[00m\]\$ '
#enables lots of colors for iTerm
export TERM=screen-256color


# enable vi mode
# https://catonmat.net/bash-vi-editing-mode-cheat-sheet
# https://catonmat.net/ftp/bash-vi-editing-mode-cheat-sheet.pdf
set -o vi

# Use vim for all the things
export GEM_EDITOR='vim'
export VISUAL='mvim -f'
export EDITOR='vim -f'

# Aliases
alias ls='ls -GFh'
alias ll='ls -hl'
alias kill_puma="pkill -USR1 puma-dev"
alias tail_puma="tail -f ~/Library/Logs/puma-dev.log"

# The following requires
# brew install git bash-completion
[[ -r "/usr/local/etc/profile.d/bash_completion.sh" ]] && . "/usr/local/etc/profile.d/bash_completion.sh"

# Git stuff
alias ga='git add'
alias grh='git reset HEAD'
alias gst='git status'
alias gs='git status'
alias gpr='git pull --rebase'
alias gp='git push'
alias gpo='git push origin'
alias gpom='git push origin master'
alias gph='git push heroku'
alias gphm='git push heroku master'
alias gd='git diff'
alias gdc='git diff --cached'
alias gc='git commit -v'
alias gcm='git commit -m'
alias gca='git commit -v -a'
alias gch='git checkout'
alias gchb='git checkout -b'
alias gb='git branch'
alias gba='git branch -a'
alias gk='gitk --all &'
alias gti='git'
alias g='git'
alias gg='git grep'
alias gpu='git pull origin master'
alias gl='git log --graph --abbrev-commit --pretty=oneline --decorate'

#----------------------------------------------------------------------------------------------------------------
# Begin GitAlias Autocompletion Stuff
# https://stackoverflow.com/a/1793178
# wrap_alias takes three arguments:
# $1: The name of the alias
# $2: The command used in the alias
# $3: The arguments in the alias all in one string
# Generate a wrapper completion function (completer) for an alias
# based on the command and the given arguments, if there is a
# completer for the command, and set the wrapper as the completer for
# the alias.
function wrap_alias() {
  [[ "$#" == 3 ]] || return 1

  local alias_name="$1"
  local aliased_command="$2"
  local alias_arguments="$3"
  local num_alias_arguments=$(echo "$alias_arguments" | wc -w)

  # The completion currently being used for the aliased command.
  local completion=$(complete -p $aliased_command 2> /dev/null)

  # Only a completer based on a function can be wrapped so look for -F
  # in the current completion. This check will also catch commands
  # with no completer for which $completion will be empty.
  echo $completion | grep -q -- -F || return 0

  local namespace=alias_completion::

  # Extract the name of the completion function from a string that
  # looks like: something -F function_name something
  # First strip the beginning of the string up to the function name by
  # removing "* -F " from the front.
  local completion_function=${completion##* -F }
  # Then strip " *" from the end, leaving only the function name.
  completion_function=${completion_function%% *}

  # Try to prevent an infinite loop by not wrapping a function
  # generated by this function. This can happen when the user runs
  # this twice for an alias like ls='ls --color=auto' or alias l='ls'
  # and alias ls='l foo'
  [[ "${completion_function#$namespace}" != $completion_function ]] && return 0

  local wrapper_name="${namespace}${alias_name}"

  eval "
function ${wrapper_name}() {
  let \"COMP_CWORD+=$num_alias_arguments\"
  args=( \"${alias_arguments}\" )
  COMP_WORDS=( $aliased_command \${args[@]} \${COMP_WORDS[@]:1} )
  $completion_function
  }
"

  # To create the new completion we use the old one with two
  # replacements:
  # 1) Replace the function with the wrapper.
  local new_completion=${completion/-F * /-F $wrapper_name }
  # 2) Replace the command being completed with the alias.
  new_completion="${new_completion% *} $alias_name"

  eval "$new_completion"
}

# For each defined alias, extract the necessary elements and use them
# to call wrap_alias.
eval "$(alias -p | sed -e 's/alias \([^=][^=]*\)='\''\([^ ][^ ]*\) *\(.*\)'\''/wrap_alias \1 \2 '\''\3'\'' /')"

unset wrap_alias
# End GitAlias Autocompletion Stuff
#----------------------------------------------------------------------------------------------------------------

# Simple way to show git status in the prompt without needing the whole git-prompt.sh thing
Reset="\[\033[0m\]"
Red="\[\033[1;31m\]"
Green="\[\033[1;32m\]"
Blue="\[\033[1;34m\]"

gitPs1()
{
        branch="$(git symbolic-ref HEAD 2> /dev/null)";

        if [ -n "$branch" ]; then
                printf " (%s)" "${branch##refs/heads/}";
        fi
}

export PS1="$Green\u@\h$Reset:$Blue\w$Reset"'$(git branch > /dev/null 2>&1; \
if [ $? -eq 0 ]; then \
        echo "$(echo `git status` | grep "nothing to commit" > /dev/null 2>&1; \
        if [ $? -eq 0 ]; then \
                echo "'$Green'"; \
        else \
                echo "'$Red'"; \
        fi)$(gitPs1 " (%s)")'$Reset'"; \
fi)'"\$ "


